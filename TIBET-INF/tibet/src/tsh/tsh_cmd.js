//  ========================================================================
/*
NAME:   tsh_cmd.js
AUTH:   Scott Shattuck (ss)
NOTE:   Copyright (C) 1999-2009 Technical Pursuit Inc., All Rights
        Reserved. Patent Pending, Technical Pursuit Inc.

        Unless explicitly acquired and licensed under the Technical
        Pursuit License ("TPL") Version 1.5, the contents of this file
        are subject to the Reciprocal Public License ("RPL") Version 1.5
        and You may not copy or use this file in either source code or
        executable form, except in compliance with the terms and
        conditions of the RPL.

        You may obtain a copy of both the TPL and RPL (the "Licenses")
        from Technical Pursuit Inc. at http://www.technicalpursuit.com.

        All software distributed under the Licenses is provided strictly
        on an "AS IS" basis, WITHOUT WARRANTY OF ANY KIND, EITHER
        EXPRESS OR IMPLIED, AND TECHNICAL PURSUIT INC. HEREBY DISCLAIMS
        ALL SUCH WARRANTIES, INCLUDING WITHOUT LIMITATION, ANY
        WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE,
        QUIET ENJOYMENT, OR NON-INFRINGEMENT. See Licenses for specific
        language governing rights and limitations under the Licenses.

*/
//  ------------------------------------------------------------------------

/**
 * @type {TP.tsh.cmd}
 * @synopsis Provides support for the TIBET Shell (TSH) during command
 *     processing. These tags are typically not entered manually, they're
 *     normally generated by the TP.tsh.script tag during processing which
 *     focuses on the conversion of script source into a structured form that
 *     can be executed effectively.
 */

/* JSHint checking */

/* jshint evil:true
*/

//  ------------------------------------------------------------------------

TP.core.ActionElementNode.defineSubtype('tsh:cmd');

TP.tsh.cmd.addTraitsFrom(TP.tsh.Element);

//  ------------------------------------------------------------------------
//  Type Attributes
//  ------------------------------------------------------------------------

//  A list of operators which are specific to runtime TSH processing. NOTE
//  that operators which desugar to XML tags are not handled here, they are
//  processed by the tsh:script tag during XML desugaring.
TP.tsh.cmd.Type.defineAttribute('$tshOperators', TP.ac('^'));

//  ------------------------------------------------------------------------
//  Type Methods
//  ------------------------------------------------------------------------

TP.tsh.cmd.Type.defineMethod('$desugarTSH',
function(aString, aShell, aRequest, asTokens) {

    /**
     * @name $desugarTSH
     * @synopsis Processes the string for TSH-specific sugars such as regex
     *     history replacements, aliases, command substitutions, variable
     *     substitutions, etc. and returns the result.
     * @param {String} aString The source string to tokenize.
     * @param {TP.core.Shell} aShell The shell instance.
     * @param {TP.sig.Request} aRequest The shell request.
     * @param {Boolean} asTokens True to return the token array.
     * @returns {String|Array} A desugared string or token list.
     * @todo
     */

    var START$$,
        END$$,
        TIME$$,
        RESULT$$,

    //  standard "special variables" we're willing to expose to scripts
        $LASTREQ,
        $REQUEST,
        $NODE,
        $SHELL,
        $CONTEXT,
        $SCOPE,
        $SCRIPT,

        str,
        arr,
        len,
        err,
        i,
        token,
        value,
        result,
        alias,
        next,
        offset,
        j,
        last,
        msg,

        inFunction,
        brackets,
        previous,
        command,
        parts,
        histMatcher,
        req,
        rewrites,
        result2,
        
        sourcevars;

    TP.debug('break.tsh_desugar');

    str = aString;

    //  use the condense routine to tokenize our content for runtime parse
    //  but explicitly turn off whitespace removal.
    arr = TP.$condenseJS(str, false, false,
                            this.$tshOperators,
                            true, true, true);

    len = arr.length;
    i = 0;

    if (TP.notValid(token = arr[i])) {
        return str;
    }

    //  initialize our function nesting control vars
    inFunction = false;
    brackets = 0;

    //  set up our output buffer
    result = TP.ac();

    rewrites = TP.ac();

    //  the initial token can be an alias, a history regex substitution, or
    //  an escape for aliasing, etc. we have to watch for them before we
    //  begin the main token processing loop.
    switch (token.value) {
        case '\\':
            //  leading escape means don't bother looking up alias
            //  translation for what follows, but strip the escape itself.
            i += 1;
            break;

        case '^':

            TP.debug('break.tsh_history');

            //  regular expression-based history substitution relative to
            //  the previous command's fully-expanded text content
            previous = aShell.getHistory().at(-2);
            if (TP.isValid(previous)) {
                command = previous.at('cmd');

                //  form is ^old^new^flags where flags are optional
                parts = str.split('^');
                histMatcher = TP.rc(parts.at(1),
                                    TP.ifInvalid(parts.at(3), ''));

                if (TP.notValid(histMatcher)) {
                    msg = TP.join(
                            TP.sc('Invalid history regexp substitution: '),
                            parts.at(1),
                            ' ',
                            TP.ifInvalid(parts.at(3), ''));

                    aRequest.fail(TP.FAILURE, msg);

                    return;
                }

                str = command.replace(histMatcher, parts.at(2));

                //  tricky thing here is that the rewrite might well have
                //  changed then entire nature of the prior command's text
                //  and either one might require asynchronous processing. As
                //  a result we effectively have to construct a new request
                //  and join it to the current one so we don't complete
                //  until the newly generated command text has been
                //  processed.
                req = TP.sig.ShellRequest.construct(
                        TP.hc('cmd', str,
                                'cmdAsIs', aRequest.at('cmdAsIs'),
                                'cmdExecute', true,
                                'cmdHistory', aRequest.at('cmdHistory'),
                                'cmdInteractive', aRequest.at('cmdInteractive'),
                                'cmdLiteral', aRequest.at('cmdLiteral'),
                                'cmdPeer', aRequest,
                                'cmdPhases', aRequest.at('cmdPhases'),
                                'cmdRecycle', aRequest.at('cmdRecycle'),
                                'cmdShell', aRequest.at('cmdShell'),
                                'cmdSilent', aRequest.at('cmdSilent')
                        ));

                req.defineMethod(
                    'cancel',
                    function(aFaultCode, aFaultString) {

                        return aRequest.cancel(
                            TP.ifInvalid(
                                    aFaultCode,
                                    TP.FAILURE),
                            TP.ifInvalid(
                                    aFaultString,
                                    TP.sc('History request cancelled.')));
                    });

                req.defineMethod(
                    'complete',
                    function(aResult) {

                        if (arguments.length > 0) {
                            return aRequest.complete(aResult);
                        } else {
                            return aRequest.complete();
                        }
                    });

                req.defineMethod(
                    'fail',
                    function(aFaultCode, aFaultString) {

                        return aRequest.fail(
                            TP.ifInvalid(
                                    aFaultCode,
                                    TP.FAILURE),
                            TP.ifInvalid(
                                    aFaultString,
                                    TP.sc('History request failed.')));
                    });

                aShell.handleShellRequest(req);

                return;
            } else {
                msg = TP.sc('No previous command to edit.');
                aRequest.fail(TP.FAILURE, msg);

                return;
            }

            break;

        case 'function':

            inFunction = true;
            result.push(token.value);
            i += 1;

            break;

        default:

            if (TP.$is_identifier(token.name)) {
                if (TP.isValid(aShell)) {
                    //  might be an alias, so we have to check for that
                    alias = aShell.getAlias(token.value);
                }

                //  if there was an alias then we have to re-submit for
                //  processing since the alias could reference new tags or
                //  other content the tsh_cmd tag can't process itself.
                if (alias !== token.value) {
                    TP.debug('break.tsh_alias');

                    //  before we submit as a "new request" we have to
                    //  process any local variable interpolations in the
                    //  alias such as ARGV or named argument references.
                    str = this.$interpolateAlias(alias, arr.slice(1));
                    str = this.$desugarTSH(str, aShell, aRequest, asTokens);

                    //  if the desugaring failed the request we're already
                    //  done...something like `blah` exploded or a ${blah}
                    //  failed to resolve etc.
                    if (aRequest.didComplete()) {
                        return;
                    }

                    req = TP.sig.ShellRequest.construct(
                        TP.hc('cmd', str,
                                'cmdAsIs', aRequest.at('cmdAsIs'),
                                'cmdExecute', true,
                                'cmdHistory', aRequest.at('cmdHistory'),
                                'cmdInteractive', aRequest.at('cmdInteractive'),
                                'cmdLiteral', aRequest.at('cmdLiteral'),
                                'cmdPeer', aRequest,
                                'cmdPhases', aRequest.at('cmdPhases'),
                                'cmdShell', aRequest.at('cmdShell'),
                                'cmdRecycle', aRequest.at('cmdRecycle'),
                                'cmdSilent', aRequest.at('cmdSilent')
                        ));

                    req.defineMethod(
                        'cancel',
                        function(aFaultCode, aFaultString) {

                            return aRequest.cancel(
                                TP.ifInvalid(
                                    aFaultCode,
                                    TP.FAILURE),
                                TP.ifInvalid(
                                    aFaultString,
                                    TP.sc('Aliased request cancelled.')));
                        });

                    req.defineMethod(
                        'complete',
                        function(aResult) {

                            if (arguments.length > 0) {
                                return aRequest.complete(aResult);
                            } else {
                                return aRequest.complete();
                            }
                        });

                    req.defineMethod(
                        'fail',
                        function(aFaultCode, aFaultString) {

                            return aRequest.fail(
                                TP.ifInvalid(
                                    aFaultCode,
                                    TP.FAILURE),
                                TP.ifInvalid(
                                    aFaultString,
                                    'Aliased request failed: ' +
                                        this.at('cmd')));
                        });

                    req.defineMethod(
                        'stderr',
                        function(output, request) {

                            return aRequest.stderr(output, request);
                        });

                    req.defineMethod(
                        'stdin',
                        function() {

                            return aRequest.stdin();
                        });

                    req.defineMethod(
                        'stdout',
                        function(output, request) {

                            return aRequest.stdout(output, request);
                        });

                    aShell.handleShellRequest(req);

                    return;
                } else {
                    //  if the next non-whitespace token is an assignment
                    //  operator then we're looking at a possible local
                    //  variable assignment we need to rewrite. The big
                    //  question is whether we see that as an undefined
                    //  slot when we check the global scope. If the slot
                    //  is defined then we presume it's a global var.
                    if (TP.isValid(next = arr.at(i + 1))) {
                        //  skip any intervening whitespace
                        offset = 2;
                        while (next && TP.$is_whitespace(next.name)) {
                            next = arr.at(i + offset);
                            offset++;
                        }

                        //  assignment? then see if we have a previously set
                        //  global value, otherwise we'll localize to $SCOPE
                        if (next && next.value === '=') {
                            if (TP.notDefined(TP.global[token.value])) {
                                //  assignment, rewrite the identifier.
                                //result.push('$SCOPE', '.');
                                rewrites.push(token.value);
                            }
                        }
                    }

                    result.push(token.value);
                    i += 1;
                }
            }

            break;
    }

    //  Ensure consistent context variables are in place when/if we do any
    //  eval operations for resolving command substitutions.
    $REQUEST = aRequest;
    $NODE = $REQUEST.at('cmdNode');
    $SHELL = aShell;
    $LASTREQ = $SHELL.get('previous');

    //  The current context (i.e. 'window' / 'self') that the evaluated
    //  statements will be executed in. This provides those statements with
    //  their global scope.
    $CONTEXT = aShell.getExecutionContext($REQUEST);

    //  We try to keep 'slots' that have been defined during development in
    //  the shell (i.e. 'x = 2'), off of the global context. This is done
    //  with a combination of using the 'with () {...}' statement (for 'get'
    //  capability) and slight expression rewriting (for 'set' capability).
    //  See below...
    $SCOPE = aShell.getExecutionInstance($REQUEST);

    //  Only in Mozilla and IE does a 'contextual eval' (i.e. one where
    //  the global/window scope is specified) take into account the current
    //  local scope (i.e. where temp variables are defined).
    //  Other browsers (Safari and Chrome) do not. Therefore, we need to
    //  make these explicitly available on the context that we're gonna
    //  invoke the eval in.
    $CONTEXT.$LASTREQ = $LASTREQ;
    $CONTEXT.$REQUEST = $REQUEST;
    $CONTEXT.$NODE = $NODE;
    $CONTEXT.$SHELL = $SHELL;
    $CONTEXT.$CONTEXT = $CONTEXT;
    $CONTEXT.$SCOPE = $SCOPE;
    $CONTEXT.$SCRIPT = $SCRIPT;
    $CONTEXT.$_ = null;

    //  complete the token processing. this may "reprocess" the initial
    //  token if it didn't signify something particular to the start of a
    //  line such as an alias or ^-based substitution.
    while ((token = arr[i])) {
        switch (token.name) {
            case 'substitution':

                //  command substitution...effectively inlining result data
                //  where the command text is positioned.
                if (token.value.indexOf('`') === 0) {
                    if (TP.notTrue(
                        TP.ifKeyInvalid(aRequest, 'cmdInteractive', false))) {
                        aRequest.fail(
                            TP.FAILURE,
                            TP.sc(TP.join(
                                    'Security violation. Attempt to use',
                                    ' command substitution outside of',
                                    ' interactive mode.')));

                        return;
                    }

                    try {
                        $SCRIPT = $SHELL.resolveVariableSubstitutions(
                            token.value.slice(1, -1));

                        //  Refresh the context's script reference after any
                        //  substitutions and before any with() bracketing
                        //  so any internal reference to it will reflect
                        //  what's being eval'd minus the with() wrapper.
                        $CONTEXT.$SCRIPT = $SCRIPT;

                        //  We do some further massaging of the statement to
                        //  be eval'ed by enclosing it with a 'with ($SCOPE)
                        //  {...}' statement. This allows 'slots' that have
                        //  been defined previously in the shell to be found
                        //  on the $SCOPE object.

                        //  Note that the 'with()' statement has to become
                        //  part of the String that gets eval'ed to keep
                        //  non-Mozilla/IE browsers happy.
                        $SCRIPT = 'with ($SCOPE) {' + $SCRIPT + '};';

                        START$$ = Date.now();
                        RESULT$$ = $CONTEXT.eval($SCRIPT);
                        END$$ = Date.now();
                    } catch (e) {
                        END$$ = Date.now();

                        //  NOTE we slice off the file reference at the tail
                        //  since that's not accurate...we're doing
                        //  interactive input here.
                        err = TP.str(e);
                        err = (err.indexOf(':: file:') === TP.NOT_FOUND) ?
                            TP.trim(err) :
                            TP.trim(err.slice(0, err.indexOf(':: file:')));
                        err = err.endsWith('.') ? err : err + '.';

                        aRequest.fail(
                            TP.FAILURE,
                            TP.join(
                                TP.sc('Command substitution `'),
                                token.value.slice(1, -1),
                                TP.sc('` failed: '),
                                err));
                    } finally {
                        TIME$$ = TP.ifInvalid(aRequest.get('$evaltime'), 0);
                        aRequest.set('$evaltime',
                                        TIME$$ + (END$$ - START$$));
                    }

                    //  if the catch block failed the request we're done.
                    if (aRequest.didComplete()) {
                        return;
                    }

                    result.push(RESULT$$);
                } else {

                    value = token.value;

                    //  If the value has template constructs, then execute the
                    //  template, providing the shell's 'execution instance'
                    //  (i.e. it's $SCOPE) as the 'data source'.
                    if (TP.regex.HAS_ACP.test(value)) {

                        //  Since templating treats '$' variables specially
                        //  (i.e. $INDEX, etc.), and all shell variables have a
                        //  leading '$', we need to pull out the names of the
                        //  variables in our String and supply them as a set of
                        //  names that the transformation engine should treat as
                        //  'normal'.

                        //  First, we convert '${X}' into '$X' inside the
                        //  template. This is important so that the templating
                        //  engine can find these variables in their standard
                        //  '$' form.
                        TP.regex.TSH_VARSUB_EXTENDED.lastIndex = 0;
                        value = value.replace(TP.regex.TSH_VARSUB_EXTENDED,
                                                '$$$1');

                        //  Next, extract the source variables, either in '$X'
                        //  or '${X}' form into an Array where they are all
                        //  normalized to '$X'.
                        sourcevars = TP.ac();
                        TP.regex.TSH_VARSUB_EXTRACT.lastIndex = 0;
                        TP.regex.TSH_VARSUB_EXTRACT.performWith(
                                function(wholeMatch, varName) {
                                    sourcevars.push('$' + varName);
                                }, value);

                        //  Do the transformation with $SCOPE as the data
                        //  source.
                        value = value.transform(
                                        aShell.getExecutionInstance(),
                                        TP.hc('sourcevars', sourcevars));
                    } else {

                        //  Otherwise, just try to resolve any variables in the
                        //  content.
                        value = aShell.resolveVariableSubstitutions(token.value);
                    }

                    if (value === token.value) {
                        TP.regex.TSH_VARSUB_EXTRACT.lastIndex = 0;
                        aRequest.fail(
                            TP.FAILURE,
                            TP.join(
                                TP.sc('Variable substitution '),
                                value,
                                TP.sc(' failed: '),
                                value.match(TP.regex.TSH_VARSUB_EXTRACT).at(0),
                                TP.sc(' is not in scope.')));

                        return;
                    } else {
                        result.push(value);
                    }
                }

                i += 1;
                break;

            case 'string':

                //  double-quoted strings can go through interpolation if
                //  they contain any embedded `'s or ${blah}s that aren't
                //  escaped...
                if (token.value.indexOf('"') === 0) {
                    value = this.$desugarTSH(
                        token.value.unquoted('"'),
                        aShell,
                        aRequest,
                        false);

                    //  if the desugaring failed the request we're already
                    //  done...something like `blah` exploded or a ${blah}
                    //  failed to resolve etc.
                    if (aRequest.didComplete()) {
                        return;
                    }

                    //  If the value has template constructs, then execute the
                    //  template, providing the shell's 'execution instance'
                    //  (i.e. it's $SCOPE) as the 'data source'.
                    if (TP.regex.HAS_ACP.test(value)) {
                        value = value.transform(
                                    $SHELL.getExecutionInstance($REQUEST));
                    }

                    result.push('"', value, '"');
                } else {
                    //  single-quoted strings are exempt from interpolation
                    //  etc. so we can skip it and push directly into result
                    result.push(token.value);
                }

                i += 1;
                break;

            case 'operator':

                if (token.value === '{') {
                    //  Count when we're "in a function" so we know when we
                    //  leave.
                    if (inFunction) {
                        brackets++;
                    }
                } else if (token.value === '}') {
                    //  If we're closing a function we
                    if (inFunction) {
                        brackets--;
                        if (brackets === 0) {
                            inFunction = false;
                        }
                    }
                }

                result.push(token.value);
                i += 1;
                break;

            default:

                if (token.value === 'function') {
                    inFunction = true;
                    result.push(token.value);
                    i += 1;
                    break;
                }

                //  When we have an identifier that isn't part of a chain we
                //  presume assignments to that identifier are local scope
                //  operations. One thing we have to watch for is we only
                //  want to do this when the identifier is a true "lvalue"
                //  and not when it's being input as part of markup etc.
                if (TP.notTrue(inFunction) && TP.$is_identifier(token.name)) {
                    //  if the next non-whitespace token is an assignment
                    //  operator then we're looking at a possible local
                    //  variable assignment we may need to rewrite.
                    if (TP.isValid(next = arr.at(i + 1))) {
                        //  skip any intervening whitespace
                        offset = 2;
                        while (next && TP.$is_whitespace(next.name)) {
                            next = arr.at(i + offset);
                            offset++;
                        }

                        //  assignment? then see if we have a previously set
                        //  global value, otherwise we'll localize to $SCOPE
                        if (next && next.value === '=') {
                            //  so we do have an assignment, the question
                            //  is, are we looking at a true lvalue or not?
                            j = result.getSize() - 1;
                            last = result.at(j);

                            while (last) {
                                if (last === ';') {
                                    break;
                                } else if (TP.regex.WHITESPACE.test(last)) {
                                    j--;
                                    last = result[j];
                                } else {
                                    last = null;
                                }
                            }

                            if ((last === ';') &&
                                TP.notDefined(TP.global[token.value])) {
                                //  assignment, rewrite the identifier.
                                result.push('$SCOPE', '.');
                                rewrites.push(token.value);
                            }
                        }
                    }
                }

                result.push(token.value);
                i += 1;

                break;
        }
    }

    //  if there were token rewrites for scope we need to reprocess the list
    //  for any of those token values now.
    if (TP.notEmpty(rewrites)) {
        result2 = TP.ac();
        len = result.length;

        for (i = 0; i < len; i++) {
            value = result[i];
            if (rewrites.containsString(value)) {
                //  Need to be careful here. It's easy to end up changing
                //  the value of some identifier which shouldn't be changed
                //  simply because a raw var name matches some property
                //  name. For example, "sig = TP.sig".
                if (result[i - 1] !== '.') {
                    result2.push('$SCOPE', '.');
                }
            }

            result2.push(value);
        }

        result = result2;
    }

    if (TP.isTrue(asTokens)) {
        return result;
    }

    return result.join('');
});

//  ------------------------------------------------------------------------

TP.tsh.cmd.Type.defineMethod('$interpolateAlias',
function(aliasString, aTokenArray) {

    /**
     * @name $interpolateAlias
     * @synopsis Accepts an alias string translation and a set of command line
     *     tokens, interpolating them in such a way that tokens referenced by
     *     the alias string are consumed while remaining tokens are placed on
     *     the command line.
     * @param {String} aliasString The alias string to interpolate.
     * @param {Array} aTokenArray An array of the tokens on the command line
     *     found after the alias.
     * @returns {String} The interpolated command line string.
     * @todo
     */

    var argv,
        params,
        i,
        tokens,
        token,
        next,
        value,
        result,
        name,
        arr,
        format,
        str,
        num;

    TP.debug(TP.sys.cfg('break.tsh_alias') ||
                TP.sys.cfg('break.tsh_interpolate'));

    //  if the alias has no variables we can do simple concatenation
    if (!TP.regex.VARSUB.test(aliasString)) {
        return aliasString + aTokenArray.collect(
                                function(item) {

                                    return item.value;
                                }).join('');
    }

    //  if the alias has substitutions we have to tokenize it and process
    //  them as we iterate. For that to work we first have to process the
    //  rest of the command line so we know which portions are "named"
    //  parameters and which are "positional"
    argv = TP.ac();
    params = TP.hc();

    i = 0;
    tokens = [];
    token = aTokenArray[i];

    //  Step one is to collapse access paths so we don't treat things like
    //  TP.sig.Signal as a set of 5 positional parameters or fail to treat
    //  that entire reference as a value in a named parameter.
    while (token) {
        if (TP.$is_identifier(token.name)) {
            next = aTokenArray[i + 1];
            while (next &&
                    (next.value !== '=') &&
                    !TP.$is_whitespace(next.name)) {
                i += 1;
                token.value += next.value;
                next = aTokenArray[i + 1];
            }
        }

        tokens.push(token);
        i += 1;
        token = aTokenArray[i];
    }

    //  Step two is to process named argument references, which means
    //  watching for a=b form and moving those into the params object as
    //  key/value.
    i = 0;
    token = tokens[i];
    while (token) {
        if (TP.$is_identifier(token.name)) {
            next = tokens[i + 1];
            if ((next) && (next.value === '=')) {
                value = tokens[i + 2];
                if (value) {
                    params.atPut(token.value,
                        value.value);
                    i += 3;
                    token = tokens[i];

                    continue;
                }
            }
        }

        if (!TP.$is_whitespace(token.name)) {
            argv.push(token.value);
        }

        i += 1;
        token = tokens[i];
    }

    //  phase two is to iterate over the alias string's token stream
    //  replacing any substitutions we can while consuming them from the
    //  params and argv containers.
    tokens = TP.$tokenize(aliasString,
                            TP.tsh.script.$tshOperators,
                            true, false, true, true);

    i = 0;
    token = tokens[i];
    result = TP.ac();

    while (token) {
        if ((token.name === 'substitution') &&
            (token.value.charAt(0) === '$')) {
            //  Slice off the leading '${' and trailing '}'
            name = token.value.slice(2, token.value.length - 1);

            if (name.indexOf('|') !== -1) {
                arr = name.split('|');
                name = arr.at(0);
                format = arr.at(1);
            }

            num = TP.nc(name);
            if (TP.isNumber(num)) {
                value = argv.at(num);
                if (TP.isDefined(value)) {
                    argv.atPut(num, '');

                    if (TP.notEmpty(format)) {
                        result.push(TP.format(value, format));
                    } else {
                        result.push(value);
                    }
                } else {
                    result.push(token.value);
                }
            } else {
                value = params.at(name);
                if (TP.isDefined(value)) {
                    params.removeKey(name);
                    if (TP.notEmpty(format)) {
                        result.push(TP.format(value, format));
                    } else {
                        result.push(value);
                    }
                } else {
                    result.push(token.value);
                }
            }
        } else {
            result.push(token.value);
        }

        i += 1;
        token = tokens[i];
    }

    //  final phase is to write out the final command line made up of the
    //  interpolated alias string and any unused tokens from the command
    //  line.

    //  rejoin the alias string's component parts for the first part
    str = result.join('');

    //  add on any named arguments, separated by a space.
    if (TP.notEmpty(params)) {
        str += ' ' + params.asQueryString(' ');
    }

    //  add on any remaining positional arguments
    if (TP.notEmpty(argv)) {
        str += ' ' + argv.join(' ');
    }

    return str;
});

//  ------------------------------------------------------------------------

TP.tsh.cmd.Type.defineMethod('isAccessPath',
function(aTokenArray) {

    /**
     * @name isAccessPath
     * @synopsis Returns true if the token array provided represents what
     *     appears to be a viable access path.
     * @description An access path is a sugared form of property naming which
     *     can be converted into a call to TIBET's 'set' or 'get' functions. For
     *     example, a sequence of tokens such as 'a.b.c' can be resolved by a
     *     get call on 'a' of a.get('b.c'); Note that the access path syntax
     *     supported by the tsh:cmd tag includes the proposed slicing syntax for
     *     future editions of JavaScript.
     * @param {Array} aTokenArray A list of tokens to check.
     * @returns {Boolean} 
     * @todo
     */

    var arr,
        token,
        i;

    //  Only worry about access path rewrites for paths with at least 2
    //  tokens, otherwise it's a standalone identifer at most.
    if (TP.isEmpty(arr = aTokenArray) || (arr.getSize() < 2)) {
        return false;
    }

    i = 0;
    token = arr[i];

    //  First token in the stream has to be a viable identifier, we can't
    //  have paths that start with a number, or a slice.
    if (!TP.$is_identifier(token.name)) {
        return false;
    }

    //  Second token must be a period for property access.
    i += 1;
    token = arr[i];
    if (token.value !== '.') {
        return false;
    }

    i += 1;
    token = arr[i];

    //  Remainder of the path can only have identifiers, numbers, colons,
    //  commas, minus signs or additional periods to specify property
    //  access. We won't validate that they appear in precisely the right
    //  order here, but we'll ensure that no other token values/types are
    //  found.
    while (token) {
        if (!TP.$is_identifier(token.name) &&
            token.name !== 'number' &&
            token.value !== '.' &&
            token.value !== ',' &&
            token.value !== '-' &&
            token.value !== '[' &&
            token.value !== ']' &&
            token.value !== ':') {
            return false;
        }

        i += 1;
        token = arr[i];
    }

    return true;
});

//  ------------------------------------------------------------------------

TP.tsh.cmd.Type.defineMethod('cmdAddContent',
function(REQUEST$$) {

    /**
     * @name cmdAddContent
     * @synopsis Invoked when the receiver is being used as a sink with append
     *     semantics. In this case the object referenced by the receiver's
     *     content will have its cmdAddContent method called if it responds to
     *     one.
     * @param {TP.sig.Request} REQUEST$$ The request containing command input
     *     for the shell.
     */

    return this.cmdRunContent(REQUEST$$, TP.ADD);
});

//  ------------------------------------------------------------------------

TP.tsh.cmd.Type.defineMethod('cmdFilterInput',
function(REQUEST$$) {

    /**
     * @name cmdFilterInput
     * @synopsis Invoked when the receiver is being used as a filter. In this
     *     case the object referenced by the receiver's content will have its
     *     cmdFilterInput method called if it responds to one.
     * @param {TP.sig.Request} REQUEST$$ The request containing command input
     *     for the shell.
     */

    return this.cmdRunContent(REQUEST$$, TP.FILTER);
});

//  ------------------------------------------------------------------------

TP.tsh.cmd.Type.defineMethod('cmdGetContent',
function(REQUEST$$) {

    /**
     * @name cmdGetContent
     * @synopsis Executes the request's content, returning a reference to the
     *     return value of that execution. This method is invoked when the
     *     tsh:cmd is used either standalone or as a data source within a TSH
     *     script.
     * @param {TP.sig.Request} REQUEST$$ The request containing command input
     *     for the shell.
     */

    //  internal to the computation process, but shouldn't be visible
    var START$$,
        END$$,
        TIME$$,
        RESULT$$,
        TOKENS$$,
        ERR$$,
        SCRIPT$$,
        ACCESS$$,
        TYPE$$,

    //  standard "special variables" we're willing to expose to scripts
        $LASTREQ,
        $REQUEST,
        $NODE,
        $SHELL,
        $CONTEXT,
        $SCOPE,
        $SCRIPT;

    TP.debug(TP.sys.cfg('break.tsh_fetch') || TP.sys.cfg('break.tsh_cmd'));

    $REQUEST = REQUEST$$;
    $NODE = $REQUEST.at('cmdNode');
    $SHELL = $REQUEST.at('cmdShell');
    $LASTREQ = $SHELL.get('previous');

    //  tokenize the content so we can check for sugar around the various
    //  substitution and rewriting methods
    $SCRIPT = TP.nodeGetTextContent($NODE);
    if (TP.isBlank($SCRIPT)) {
        $REQUEST.complete();

        return;
    }

    //  if the command text started (originally) with an escape then literal
    //  will be set to true so we don't attempt desugaring
    if (($NODE.getAttribute('tsh:literal') !== 'true') &&
        ($REQUEST.at('cmdLiteral') !== true)) {
        $SCRIPT = this.$desugarTSH($SCRIPT, $SHELL, $REQUEST);

        //  certain desugaring attempts can recognize that the request is
        //  malformed and fail() it.
        if ($REQUEST.didComplete()) {
            return;
        }

        TP.nodeSetTextContent($NODE, $SCRIPT);
    }

    //  tokenize what's left so we can check for identifiers etc.
    TOKENS$$ = TP.$condenseJS($SCRIPT, false, false,
                                this.$tshOperators,
                                true, true, true);

    if (this.isAccessPath(TOKENS$$)) {
        ACCESS$$ = true;

        //  first token in an access path is the object reference,
        //  the rest can be wrapped into a string access path...
        $SCRIPT = TOKENS$$[0].value +
                    '.get(TP.apc(\'' +
                    TOKENS$$.slice(2).collect(
                        function(item) {

                            return item.value;
                        }).join('') + '\'));';

        TP.nodeSetTextContent($NODE, $SCRIPT);
    }

    try {
        //  The current context (i.e. 'window' / 'self') that the evaluated
        //  statements will be executed in. This provides those statements
        //  with their global scope.
        $CONTEXT = $SHELL.getExecutionContext($REQUEST);

        //  We try to keep 'slots' that have been defined during development
        //  in the shell (i.e. 'x = 2'), off of the global context. This is
        //  done with a combination of using the 'with () {...}' statement
        //  (for 'get' capability) and slight expression rewriting (for
        //  'set' capability). See below...
        $SCOPE = $SHELL.getExecutionInstance($REQUEST);

        //  Only in Mozilla and IE does a 'contextual eval' (i.e. one
        //  where the global/window scope is specified) take into account
        //  the current local scope (i.e. where temp variables are defined).
        //  Other browsers (Safari and Chrome) do not. Therefore, we need to
        //  make these explicitly available on the context that we're gonna
        //  invoke the eval in.
        $CONTEXT.$LASTREQ = $LASTREQ;
        $CONTEXT.$REQUEST = $REQUEST;
        $CONTEXT.$NODE = $NODE;
        $CONTEXT.$SHELL = $SHELL;
        $CONTEXT.$CONTEXT = $CONTEXT;
        $CONTEXT.$SCOPE = $SCOPE;
        $CONTEXT.$SCRIPT = $SCRIPT;
        $CONTEXT.$_ = null;

        //  We do some further massaging of the statement to be eval'ed
        //  by enclosing it with a 'with ($SCOPE) {...}' statement. This
        //  allows 'slots' that have been defined previously in the shell to
        //  be found on the $SCOPE object.

        //  Note that the 'with()' statement has to become part of the
        //  String that gets eval'ed to keep non-Mozilla/IE browsers happy.
        SCRIPT$$ = 'with ($SCOPE) {' + $SCRIPT + '};';

        START$$ = Date.now();
        RESULT$$ = $CONTEXT.eval(SCRIPT$$);
        END$$ = Date.now();

        TIME$$ = TP.ifInvalid($REQUEST.get('$evaltime'), 0);
        $REQUEST.set('$evaltime', TIME$$ + (END$$ - START$$));

        //  After resolving the reference, we see if the result (or it's type)
        //  can execute 'cmdGetContent'.

        if (TP.canInvoke(RESULT$$, 'cmdGetContent')) {
            RESULT$$ = RESULT$$.cmdGetContent($REQUEST);
        } else if (TP.isType(TYPE$$ = TP.type(RESULT$$))) {

            if (TP.canInvoke(TYPE$$, 'cmdGetContent')) {
                $REQUEST.atPut('cmdInstance', RESULT$$);
                RESULT$$ = TYPE$$.cmdGetContent($REQUEST);
            }
        }

        $REQUEST.complete(RESULT$$);
    } catch (e) {
        END$$ = Date.now();

        TIME$$ = TP.ifInvalid($REQUEST.get('$evaltime'), 0);
        $REQUEST.set('$evaltime', TIME$$ + (END$$ - START$$));

        //  NOTE we slice off the file reference at the tail
        //  since that's not accurate...we're doing
        //  interactive input here.
        ERR$$ = TP.str(e);
        if (ERR$$.contains(' &#171; ')) {
            ERR$$ = TP.trim(ERR$$.slice(0, ERR$$.indexOf(' &#171; ')));
        }

        if (/[sS]yntax/.test(ERR$$)) {
            RESULT$$ = ERR$$ + ': ' + $SCRIPT;
        } else {
            RESULT$$ = ERR$$.endsWith('.') ? ERR$$ : ERR$$ + '.';
        }

        $REQUEST.fail(TP.FAILURE, RESULT$$);
    }

    return;
});

//  ------------------------------------------------------------------------

TP.tsh.cmd.Type.defineMethod('cmdRunContent',
function(REQUEST$$, CMDTYPE$$) {

    /**
     * @name cmdRunContent
     * @synopsis Invoked when the receiver is being used as either a filter or a
     *     sink in a pipe (otherwise cmdGetContent() is called).
     * @param {TP.sig.Request} REQUEST$$ The request containing command input
     *     for the shell.
     */

    //  internal to the computation process, but shouldn't be visible
    var PIPE$$,
        RESULT$$,
        TOKENS$$,
        TOKEN$$,
        QUERY$$,
        RE$$,
        ACCESS$$,
        EXEC$$,
        TYPE$$,
        CTYPE$$,

    //  standard "special variables" we're willing to expose to scripts
        $LASTREQ,
        $REQUEST,
        $NODE,
        $TPNODE,
        $SHELL,
        $CONTEXT,
        $SCOPE,
        $SCRIPT;

    TP.debug('break.tsh_cmd');

    $REQUEST = REQUEST$$;

    $SHELL = $REQUEST.at('cmdShell');
    $LASTREQ = $SHELL.$LASTREQ;
    $LASTREQ = $SHELL.get('previous');

    $NODE = $REQUEST.at('cmdNode');
    $TPNODE = TP.wrap($NODE);

    $SCRIPT = TP.trim(TP.nodeGetTextContent($NODE));
    if (TP.isBlank($SCRIPT)) {
        $REQUEST.complete();

        return;
    }

    //  The current context (i.e. 'window' / 'self') that the evaluated
    //  statements will be executed in. This provides those statements with
    //  their global scope.
    $CONTEXT = $SHELL.getExecutionContext($REQUEST);

    //  We try to keep 'slots' that have been defined during development in
    //  the shell (i.e. 'x = 2'), off of the global context. This is done
    //  with a combination of using the 'with () {...}' statement (for 'get'
    //  capability) and slight expression rewriting (for 'set' capability).
    //  See below...
    $SCOPE = $SHELL.getExecutionInstance($REQUEST);

    //  Only in Mozilla and IE does a 'contextual eval' (i.e. one where
    //  the global/window scope is specified) take into account the current
    //  local scope (i.e. where temp variables are defined).
    //  Other browsers (Safari and Chrome) do not. Therefore, we need to
    //  make these explicitly available on the context that we're gonna
    //  invoke the eval in.
    $CONTEXT.$LASTREQ = $LASTREQ;
    $CONTEXT.$REQUEST = $REQUEST;
    $CONTEXT.$NODE = $NODE;
    $CONTEXT.$SHELL = $SHELL;
    $CONTEXT.$CONTEXT = $CONTEXT;
    $CONTEXT.$SCOPE = $SCOPE;
    $CONTEXT.$SCRIPT = $SCRIPT;

    PIPE$$ = TP.elementGetAttribute($NODE, 'tsh:pipe', true);

    //  there are a few pipe symbols which, while they are part of the
    //  overall pipe syntax, imply the current element shouldn't try to read
    //  from stdin since it's at a segment break. when that's true we clear
    //  the pipe symbol so we'll more likely drop through to a cmdGetContent
    if (TP.$is_ioend(PIPE$$)) {
        PIPE$$ = null;
    }

    //  convert to expand any aliases etc. unless literal text is forced
    if (($NODE.getAttribute('tsh:literal') !== 'true') &&
        ($REQUEST.at('cmdLiteral') !== true)) {
        $SCRIPT = this.$desugarTSH($SCRIPT, $SHELL, $REQUEST);

        //  certain desugaring attempts can recognize that the request is
        //  malformed and fail() it.
        if ($REQUEST.didComplete()) {
            return;
        }

        TP.nodeSetTextContent($NODE, $SCRIPT);
    }

    //  if the desgugaring process didn't return a viable script then we
    //  have to presume that we're being sidetracked to another request
    //  (typically due to a history rewrite of some kind). In those cases
    //  we have to simply wait for any nested request to come back around
    //  and notify this request when it completes.
    if (TP.isBlank($SCRIPT)) {
        return;
    }

    //  first phase is to adjust the script to deal with a special case
    //  around targeting a new identifier as a sink as in 1+2 .> foo. If foo
    //  isn't already a symbol then the script won't work properly and we'll
    //  get an error about foo being undefined. If foo already exists we
    //  want to protect it with clobber/noclobber via the ! suffix.
    CTYPE$$ = CMDTYPE$$;
    switch (CMDTYPE$$) {
        case 'add':
        case 'set':

            //  tokenize what's left so we can check for identifiers etc.
            TOKENS$$ = TP.$condenseJS($SCRIPT, false, false,
                                        this.$tshOperators,
                                        true, true, true);

            //  one special case for sinks is when sugaring for setting a
            //  variable or property. in those cases we're looking for a strict
            //  identifier[.identifier] pattern identifying at most one target
            //  object or variable. If the length is just one identifier it's
            //  even more special.
            if (TOKENS$$.length === 1) {
                TOKEN$$ = TOKENS$$[0];
                if (TOKEN$$ && TP.$is_identifier(TOKEN$$.name)) {
                    //  could be a variable reference. if that variable isn't
                    //  set as a scoped variable then we'll do that manually,
                    //  otherwise we can get the object and test as needed.
                    if (TP.notDefined($SCOPE[TOKEN$$.value])) {
                        //  new variable setter...adjust script
                        $SCRIPT = '$SCOPE.' + TOKEN$$.value + ' = $INPUT';
                        TP.nodeSetTextContent($NODE, $SCRIPT);

                        //  adjust our command type so we can exit cleanly down
                        //  below without trying to use the result
                        CTYPE$$ = 'var';
                    }
                } else {
                    //  TODO: Had a token, but it's not an identifier?
                }
            } else if (this.isAccessPath(TOKENS$$)) {
                //  Set a flag we can check later to see that this command has
                //  been rewritten as an access path, and therefore no
                //  additional work should be done after object resolution has
                //  occurred to add/set content.
                ACCESS$$ = true;

                //  first token in an access path the the object reference, the
                //  rest can be wrapped into a string access path...
                $SCRIPT = TOKENS$$[0].value + '.set(TP.apc(\'' +
                    TOKENS$$.slice(2).collect(
                        function(item) {

                            return item.value;
                        }).join('') + '\').set(\'makeStruct\', true), $INPUT);';
                TP.nodeSetTextContent($NODE, $SCRIPT);
            } else {
                //  fall through and let the EXEC$$ code try to invoke the
                //  proper method on the RESULT$$ of the expression.
            }

            break;

        default:

            //  for potential filter/transformation operations we need to
            //  look for single-token literals which indicate a sugared
            //  filter or tranformation
            if (TP.notEmpty(PIPE$$)) {
                TOKENS$$ = TP.$condenseJS($SCRIPT, false, false,
                                            this.$tshOperators,
                                            true, true, true);

                //  all literal token representations are single tokens
                if (TOKENS$$.length === 1) {
                    QUERY$$ = (PIPE$$.indexOf('?') !== TP.NOT_FOUND);

                    TOKEN$$ = TOKENS$$[0];
                    switch (TOKEN$$.name) {
                        case 'regexp':

                            //  the token is a regex but we don't want
                            //  to eval it...just pull it apart to call
                            //  the constructor...but we have to watch
                            //  out for embedded /'s etc...
                            RE$$ = TP.rc(
                                TOKEN$$.value.slice(1,
                                    TOKEN$$.value.lastIndexOf('/')),
                                TOKEN$$.value.slice(
                                    TOKEN$$.value.lastIndexOf('/') + 1));

                            if (TP.notValid(RE$$)) {
                                RESULT$$ = 'Invalid RegExp filter: ' +
                                    TOKEN$$.value.slice(1,
                                        TOKEN$$.value.lastIndexOf('/')) +
                                    ' ' +
                                    TOKEN$$.value.slice(
                                        TOKEN$$.value.lastIndexOf('/') + 1);

                                //  problem creating regular expression
                                //  which should have reported an error
                                $REQUEST.fail(TP.FAILURE, RESULT$$);

                                return;
                            }

                            //  we already know that we have a RegExp and
                            //  that it's type implements cmdFilterInput or
                            //  cmdTransformInput, so just execute that and
                            //  return.
                            $REQUEST.atPut('cmdInstance', RE$$);
                            if (QUERY$$) {
                                RegExp.cmdFilterInput($REQUEST);
                            } else {
                                RegExp.cmdTransformInput($REQUEST);
                            }

                            return;

                        case 'string':

                            //  we already know that we have a String and
                            //  that it's type implements cmdFilterInput or
                            //  cmdTransformInput, so just execute that and
                            //  return.
                            $REQUEST.atPut('cmdInstance', TOKEN$$.value);
                            if (QUERY$$) {
                                String.cmdFilterInput($REQUEST);
                            } else {
                                String.cmdTransformInput($REQUEST);
                            }

                            return;

                        default:

                            //  single-token content...fall through

                    }
                } else if (this.isAccessPath(TOKENS$$)) {
                    //  Set a flag we can check later to see that this
                    //  command has been rewritten as an access path, and
                    //  therefore no additional work should be done after
                    //  object resolution has occurred to add/set content.
                    ACCESS$$ = true;

                    //  first token in an access path the the object
                    //  reference, the rest can be wrapped into a string
                    //  access path...
                    $SCRIPT = TOKENS$$[0].value + '.get(TP.apc(\'' +
                        TOKENS$$.slice(2).collect(
                            function(item) {

                                return item.value;
                            }).join('') + '\'), $INPUT);';
                    TP.nodeSetTextContent($NODE, $SCRIPT);
                } else {
                    //  multi-token content...fall through

                }
            } else {
                //  if we're not the target of a pipe life is easy, we're
                //  basically a "getContent" command which may/may not push
                //  our output to a downstream target.

                //  NOTE that by setting literal to true here we avoid
                //  having the getContent logic reparse/re-desugar the
                //  content.
                $REQUEST.atPut('cmdLiteral', true);

                //  NOTE also that we have to ensure a downstream
                //  nodeGetContent operation will find the updated script.
                TP.nodeSetTextContent($NODE, $SCRIPT);

                //  single-token content... we have to determine if we're the
                //  source of a piping construct of some sort (i.e. 'peek ahead'
                //  to the next command element in the pipe). If so, we have to
                //  fetch content - otherwise, we can just fall through.

                //  Note that we're looking at the pipe in the downstream
                //  segment so we want to make sure that *it* is not supposed to
                //  be doing a 'get'. If *it* is not doing a get, that means
                //  that *we* are.
                if (!$TPNODE.isLastSegment() &&
                    $TPNODE.getDownstreamSegment().getRedirectionType() !==
                                                                    TP.GET) {
                    return this.cmdGetContent($REQUEST);
                }
            }

            break;
    }

    //  ---
    //  helper function
    //  ---

    EXEC$$ = function(COMPLETE$$) {

        var INPUT$$,
            LOOP$$,
            LEN$$,
            I$$,
            START$$,
            END$$,
            ERR$$,
            TIME$$,
            SCRIPT$$;

        TP.debug('break.tsh_execute');

        INPUT$$ = $REQUEST.stdin();
        LOOP$$ = $REQUEST.at('cmdIterate');

        LEN$$ = INPUT$$.getSize();

        //  one possible issue is when the previous command didn't write
        //  output for whatever reason, but the pipe was constructed as if
        //  the current element should expect input. when that's the case we
        //  "fake" a single null as the input data.
        if (LEN$$ === 0) {
            INPUT$$ = TP.ac(null);
            LEN$$ = 1;
        }

        //  We do some further massaging of the statement to be eval'ed
        //  by enclosing it with a 'with ($SCOPE) {...}' statement. This
        //  allows 'slots' that have been defined previously in the shell to
        //  be found on the $SCOPE object.

        //  Note that the 'with()' statement has to become part of the
        //  String that gets eval'ed to keep non-Mozilla/IE browsers happy.
        SCRIPT$$ = 'with ($SCOPE) {' + $SCRIPT + '};';

        for (I$$ = 0; I$$ < LEN$$; I$$++) {

            $SCOPE.$INPUT = INPUT$$.at(I$$);

            try {
                START$$ = Date.now();
                if (LOOP$$) {
                    if (TP.isCollection($SCOPE.$INPUT)) {
                        RESULT$$ = $SCOPE.$INPUT.collect(
                            function(ITEM$$, INDEX$$) {

                                $SCOPE.$INDEX = INDEX$$;
                                $SCOPE.$_ = ITEM$$;

                                return $CONTEXT.eval(SCRIPT$$);
                            });
                    } else {
                        //  splatted on non-collection...
                        $SCOPE.$_ = $SCOPE.$INPUT;
                        RESULT$$ = TP.ac($CONTEXT.eval(SCRIPT$$));
                    }
                } else {
                    $SCOPE.$_ = $SCOPE.$INPUT;
                    RESULT$$ = $CONTEXT.eval(SCRIPT$$);
                }
                END$$ = Date.now();

                TIME$$ = TP.ifInvalid($REQUEST.get('$evaltime'), 0);
                $REQUEST.set('$evaltime', TIME$$ + (END$$ - START$$));

                if (TP.notFalse(COMPLETE$$)) {
                    $REQUEST.complete(RESULT$$);
                }
            } catch (e) {
                END$$ = Date.now();
                TIME$$ = TP.ifInvalid($REQUEST.get('$evaltime'), 0);
                $REQUEST.set('$evaltime', TIME$$ + (END$$ - START$$));

                //  NOTE we slice off the file reference at the tail
                //  since that's not accurate...we're doing
                //  interactive input here.
                ERR$$ = TP.str(e);
                ERR$$ = (ERR$$.indexOf(':: file:') === TP.NOT_FOUND) ?
                    TP.trim(ERR$$) :
                    TP.trim(ERR$$.slice(0, ERR$$.indexOf(':: file:')));
                if (/[sS]yntax/.test(ERR$$)) {
                    RESULT$$ = ERR$$ + ': ' + $SCRIPT;
                } else if (/missing ; before statement/.test(ERR$$)) {
                    //  Rewrites of commands/aliases etc. can sometimes
                    //  cause eval to output a useless message about a
                    //  missing ;. In those cases we want to be sure to dump
                    //  the script.
                    RESULT$$ = 'syntax error: ' + $SCRIPT;
                } else {
                    RESULT$$ = ERR$$.endsWith('.') ? ERR$$ : ERR$$ + '.';
                }

                $REQUEST.fail(TP.FAILURE, RESULT$$);

                return;
            }
        }
    };

    //  with our execution helper ready we can now process the command types
    //  and work off their results as needed.
    switch (CTYPE$$) {
        case 'var':

            //  exec once to set variable, then our work is finished
            $REQUEST.atPut('cmdIterate', false);
            EXEC$$();

            break;

        case TP.ADD:

            //  no splatting or other iterations are relevant for 'add' and
            //  we can't complete inside the exec call, we have to wait.
            $REQUEST.atPut('cmdIterate', false);
            EXEC$$(TP.ifInvalid(ACCESS$$, false));

            //  If the eval catch block triggered the request will have
            //  failed so no point in continuing.
            if ($REQUEST.didComplete()) {
                return;
            }

            if (TP.canInvoke(RESULT$$, 'cmdAddContent')) {
                RESULT$$ = RESULT$$.cmdAddContent($REQUEST);
            } else if (TP.isType(TYPE$$ = TP.type(RESULT$$))) {

                if (TP.canInvoke(TYPE$$, 'cmdAddContent')) {
                    $REQUEST.atPut('cmdInstance', RESULT$$);
                    RESULT$$ = TYPE$$.cmdAddContent($REQUEST);
                } else {
                    $REQUEST.fail(TP.FAILURE, 'Invalid sink.');
                }
            } else if (!TP.isMutable(RESULT$$)) {
                $REQUEST.fail(TP.FAILURE, 'Non-mutable sink.');
            } else {
                $REQUEST.fail(TP.FAILURE, 'Missing sink.');
            }

            break;

        case TP.FILTER:

            //  we can't complete inside the exec call, we have to wait.
            EXEC$$(TP.ifInvalid(ACCESS$$, false));

            //  If the eval catch block triggered the request will have
            //  failed so no point in continuing.
            if ($REQUEST.didComplete()) {
                return;
            }

            //  If the script doesn't reference either $INPUT or $_ (and hence
            //  couldn't have done "real work" on the inbound data) then we
            //  message the result object to get the content to filter.

            if (/\$INPUT/.test($SCRIPT) !== true &&
                /\$_/.test($SCRIPT) !== true) {

                if (TP.canInvoke(RESULT$$, 'cmdFilterInput')) {
                    RESULT$$ = RESULT$$.cmdFilterInput($REQUEST);
                } else if (TP.isType(TYPE$$ = TP.type(RESULT$$))) {

                    if (TP.canInvoke(TYPE$$, 'cmdFilterInput')) {
                        $REQUEST.atPut('cmdInstance', RESULT$$);
                        RESULT$$ = TYPE$$.cmdFilterInput($REQUEST);
                    } else {
                        $REQUEST.fail(TP.FAILURE, 'Invalid pipe.');
                    }
                } else {
                    $REQUEST.complete(RESULT$$);
                }
            } else {
                $REQUEST.complete(RESULT$$);
            }

            break;

        case TP.SET:

            //  no splatting or other iterations are relevant for 'set' and
            //  we can't complete inside the exec call, we have to wait.
            $REQUEST.atPut('cmdIterate', false);
            EXEC$$(TP.ifInvalid(ACCESS$$, false));

            //  If the eval catch block triggered the request will have
            //  failed so no point in continuing.
            if ($REQUEST.didComplete()) {
                return;
            }

            if (TP.canInvoke(RESULT$$, 'cmdSetContent')) {
                RESULT$$ = RESULT$$.cmdSetContent($REQUEST);
            } else if (TP.isType(TYPE$$ = TP.type(RESULT$$))) {

                if (TP.canInvoke(TYPE$$, 'cmdSetContent')) {
                    $REQUEST.atPut('cmdInstance', RESULT$$);
                    RESULT$$ = TYPE$$.cmdSetContent($REQUEST);
                } else {
                    $REQUEST.fail(TP.FAILURE, 'Invalid sink.');
                }
            } else if (!TP.isMutable(RESULT$$)) {
                $REQUEST.fail(TP.FAILURE, 'Non-mutable sink.');
            } else {
                $REQUEST.fail(TP.FAILURE, 'Missing sink.');
            }

            break;

        case TP.TRANSFORM:

            //  we can't complete inside the exec call, we have to wait.
            EXEC$$(TP.ifInvalid(ACCESS$$, false));

            //  If the eval catch block triggered the request will have
            //  failed so no point in continuing.
            if ($REQUEST.didComplete()) {
                return;
            }

            //  If the script doesn't reference either $INPUT or $_ (and hence
            //  couldn't have done "real work" on the inbound data) then we
            //  message the result object to get the content to filter.

            if (/\$INPUT/.test($SCRIPT) !== true &&
                /\$_/.test($SCRIPT) !== true) {

                if (TP.canInvoke(RESULT$$, 'cmdTransformInput')) {
                    RESULT$$ = RESULT$$.cmdTransformInput($REQUEST);
                } else if (TP.isType(TYPE$$ = TP.type(RESULT$$))) {

                    if (TP.canInvoke(TYPE$$, 'cmdTransformInput')) {
                        $REQUEST.atPut('cmdInstance', RESULT$$);
                        RESULT$$ = TYPE$$.cmdTransformInput($REQUEST);
                    } else {
                        $REQUEST.fail(TP.FAILURE, 'Invalid pipe.');
                    }
                } else {
                    $REQUEST.complete(RESULT$$);
                }
            } else {
                $REQUEST.complete(RESULT$$);
            }

            break;

        default:

            EXEC$$();
            break;
    }

    return;
});

//  ------------------------------------------------------------------------

TP.tsh.cmd.Type.defineMethod('cmdSetContent',
function(REQUEST$$) {

    /**
     * @name cmdSetContent
     * @synopsis Invoked when the receiver is being used as a sink with set
     *     semantics. In this case the object referenced by the receiver's
     *     content should have its setContent method called if it responds to
     *     one.
     * @param {TP.sig.Request} REQUEST$$ The request containing command input
     *     for the shell.
     */

    return this.cmdRunContent(REQUEST$$, TP.SET);
});

//  ------------------------------------------------------------------------

TP.tsh.cmd.Type.defineMethod('cmdTransformInput',
function(REQUEST$$) {

    /**
     * @name cmdTransformInput
     * @synopsis Invoked when the receiver is being used as a transform. In this
     *     case the object referenced by the receiver's content will its
     *     cmdTransformInput method called if it responds to one.
     * @param {TP.sig.Request} REQUEST$$ The request containing command input
     *     for the shell.
     */

    return this.cmdRunContent(REQUEST$$, TP.TRANSFORM);
});

//  ------------------------------------------------------------------------

TP.tsh.cmd.Type.defineMethod('expandContent',
function(aString, aShell, aRequest) {

    /**
     * @name expandContent
     * @synopsis Expands content contained in the supplied source string using
     *     the provided shell.
     * @description Content expansion consists of expanding any command
     *     substitutions (content inside of `...` constructs) and any executing
     *     any templates. Note that this does *not* include resolving of
     *     variable values, either by variable expansion or by object resolution
     *     However, variables in templates will be expanded to their fully
     *     realized values.
     * @param {String} aString The source string to expand content in.
     * @param {TP.core.Shell} aShell The shell instance.
     * @param {TP.sig.Request} aRequest The request containing command input for
     *     the shell.
     * @returns {String} The source string with the content expanded.
     */

    var result,
    
        RESULT$$,

    //  standard "special variables" we're willing to expose to scripts
        $LASTREQ,
        $REQUEST,
        $NODE,
        $SHELL,
        $CONTEXT,
        $SCOPE,
        $SCRIPT,
    
        err,

        value,
        sourcevars;

    //  set up our output buffer
    result = TP.ac();

    //  command substitution...effectively inlining result data where the
    //  command text is positioned.
    if (aString.indexOf('`') === 0) {

        //  Ensure consistent context variables are in place when/if we do any
        //  eval operations for resolving command substitutions.
        $REQUEST = aRequest;
        $NODE = $REQUEST.at('cmdNode');
        $SHELL = aShell;
        $LASTREQ = $SHELL.get('previous');

        //  The current context (i.e. 'window' / 'self') that the evaluated
        //  statements will be executed in. This provides those statements with
        //  their global scope.
        $CONTEXT = aShell.getExecutionContext($REQUEST);

        //  We try to keep 'slots' that have been defined during development in
        //  the shell (i.e. 'x = 2'), off of the global context. This is done
        //  with a combination of using the 'with () {...}' statement (for 'get'
        //  capability) and slight expression rewriting (for 'set' capability).
        //  See below...
        $SCOPE = aShell.getExecutionInstance($REQUEST);

        //  Only in Mozilla and IE does a 'contextual eval' (i.e. one where
        //  the global/window scope is specified) take into account the current
        //  local scope (i.e. where temp variables are defined).
        //  Other browsers (Safari and Chrome) do not. Therefore, we need to
        //  make these explicitly available on the context that we're gonna
        //  invoke the eval in.
        $CONTEXT.$LASTREQ = $LASTREQ;
        $CONTEXT.$REQUEST = $REQUEST;
        $CONTEXT.$NODE = $NODE;
        $CONTEXT.$SHELL = $SHELL;
        $CONTEXT.$CONTEXT = $CONTEXT;
        $CONTEXT.$SCOPE = $SCOPE;
        $CONTEXT.$SCRIPT = $SCRIPT;
        $CONTEXT.$_ = null;

        if (TP.notTrue(
            TP.ifKeyInvalid(aRequest, 'cmdInteractive', false))) {
            aRequest.fail(
                TP.FAILURE,
                TP.sc(TP.join(
                        'Security violation. Attempt to use',
                        ' command substitution outside of',
                        ' interactive mode.')));

            return;
        }

        try {
            $SCRIPT = $SHELL.resolveVariableSubstitutions(aString.slice(1, -1));

            //  Refresh the context's script reference after any substitutions
            //  and before any with() bracketing so any internal reference to it
            //  will reflect what's being eval'd minus the with() wrapper.
            $CONTEXT.$SCRIPT = $SCRIPT;

            //  We do some further massaging of the statement to be eval'ed by
            //  enclosing it with a 'with ($SCOPE) {...}' statement. This allows
            //  'slots' that have been defined previously in the shell to be
            //  found on the $SCOPE object.

            //  Note that the 'with()' statement has to become part of the
            //  String that gets eval'ed to keep non-Mozilla/IE browsers happy.
            $SCRIPT = 'with ($SCOPE) {' + $SCRIPT + '};';

            RESULT$$ = $CONTEXT.eval($SCRIPT);
        } catch (e) {

            //  NOTE we slice off the file reference at the tail since that's
            //  not accurate...we're doing interactive input here.
            err = TP.str(e);
            err = (err.indexOf(':: file:') === TP.NOT_FOUND) ?
                TP.trim(err) :
                TP.trim(err.slice(0, err.indexOf(':: file:')));
            err = err.endsWith('.') ? err : err + '.';

            aRequest.fail(
                TP.FAILURE,
                TP.join(
                    TP.sc('Command substitution `'),
                    aString.slice(1, -1),
                    TP.sc('` failed: '),
                    err));
        }

        //  if the catch block failed the request we're done.
        if (aRequest.didComplete()) {
            return;
        }

        result.push(RESULT$$);
    } else {

        //  Templating

        value = aString;

        //  If the value is an ACP template, then we use template
        //  transformation. We do *not* resolve variable substitutions using the
        //  normal mechanism before transforming the template or otherwise we'll
        //  have literal values in the template, which won't work. Instead, we
        //  supply the shell's 'execution instance' (i.e. $SCOPE) to the
        //  templating engine as a 'data source'.
        if (TP.regex.HAS_ACP.test(value)) {

            //  Since templating treats '$' variables specially (i.e. $INDEX,
            //  etc.), and all shell variables have a leading '$', we need to
            //  pull out the names of the variables in our String and supply
            //  them as a set of names that the transformation engine should
            //  treat as 'normal'.
            
            //  First, we convert '${X}' into '$X'
            TP.regex.TSH_VARSUB_EXTENDED.lastIndex = 0;
            value = value.replace(TP.regex.TSH_VARSUB_EXTENDED, '$$$1');

            //  Next, extract the source variables, either in '$X' or '${X}' form
            //  into an Array where they are all normalized to '$X'.
            sourcevars = TP.ac();
            TP.regex.TSH_VARSUB_EXTRACT.lastIndex = 0;
            TP.regex.TSH_VARSUB_EXTRACT.performWith(
                    function(wholeMatch, varName) {
                        sourcevars.push('$' + varName);
                    }, value);

            //  Do the transformation with $SCOPE as the data source.
            value = value.transform(aShell.getExecutionInstance(),
                                    TP.hc('sourcevars', sourcevars));
        }

        result.push(value);
    }

    return result.join('');
});

//  ------------------------------------------------------------------------

TP.tsh.cmd.Type.defineMethod('tshExecute',
function(aRequest) {

    /**
     * @name tshExecute
     * @synopsis Responds to requests by the TSH to execute. The tsh:cmd tag
     *     doesn't process in this fashion, it can only be invoked as part of a
     *     tsh:script tag's execution so this method raises an
     *     TP.sig.InvalidOperation exception.
     * @param {TP.sig.Request} aRequest The request to be processed.
     * @raises TP.sig.InvalidOperation
     * @returns {TP.BREAK} 
     */

    TP.debug('break.tsh_cmd');

    this.raise('TP.sig.InvalidOperation', arguments);

    return TP.BREAK;
});

//  ------------------------------------------------------------------------
//  end
//  ========================================================================
